<!doctype html>

<html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0">
        <link rel="stylesheet" href="https://pyscript.net/releases/2024.1.1/core.css">
        <script type="module" src="https://pyscript.net/releases/2024.1.1/core.js"></script>

        <title>Watermelon++ online interpreter</title>

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">

        <style>

            body {
                font-family: "Ubuntu Mono", monospace;
            }

            .ubuntu-mono-regular {
                font-family: "Ubuntu Mono", monospace;
                font-weight: 400;
                font-style: normal;
            }

            .ubuntu-mono-bold {
                font-family: "Ubuntu Mono", monospace;
                font-weight: 700;
                font-style: normal;
            }

            .ubuntu-mono-regular-italic {
                font-family: "Ubuntu Mono", monospace;
                font-weight: 400;
                font-style: italic;
            }

            .ubuntu-mono-bold-italic {
                font-family: "Ubuntu Mono", monospace;
                font-weight: 700;
                font-style: italic;
            }

            .header {
                color: white;
                background-color: black;
            }

            #code {
              width: 87%;
              height: 300px;
            }

            #input_stream {
              width: 10%;
              height: 300px;
            }
        </style>
    </head>

    <body>
        <div class="header">
            <h1>Watermelon++ online interpreter</h1>
            <p>Based on version 3.1, system-based features, python traceback catching are excluded. Powered by pyscript</p>
        </div>
        <textarea id="code" style="display: inline-block;"></textarea>
        <textarea id="input_stream">This is the input stream. type here for scanln input</textarea>
        <br>
        <button id="run_button" style="width: 100px;" type="submit">Run</button>

        <script>
          document.getElementById("code").value = "fn main;\n  println \"Hello, world!\";\nnf;"
        </script>

        <h3>Console</h3>
        [wppinit] Loading python...
        <section class="pyscript">
            <script type="py">
                from pyscript import display
                print = display
                print("[wppinit] Python loaded")
                
import os,sys,re,shlex,traceback,_thread,time
C=time.time
d=time.time_ns
I=time.sleep
q=_thread.start_new_thread
F=traceback.format_exception
a=shlex.split
c=re.match
V=sys.excepthook
Y=os.system
variables={"!hello":"Hello, world!","WPPinput_nonblocking":0}
functions={}
ifst=[{"var":None,"equal":None,"active":False,"elsecon":False}]
namespace_info={"active":False,"name":""}
ifst=[]
loopst=[]
line_stamps=[]
toexit=0
class v:
 def o(name,details):
  global inter,toexit
  print(f"""
__Execution error__
  {name}: {details}""")
  toexit=1
  if inter==0:
   exit(-5)
   toexit=0
class S:
 def o(name,details):
  print(f"""
Warning:
  {name}: {details}""")
class h:
 def __init__(self,scope={}):
  self.scope=scope
  self.timed_vars=[]
scopes={"global":h(variables.copy()),"essential":h()}
current_scope="global"
pyexec_allowed=True
class U:
 def __init__(self,varname,lifetime_number,lifetime_number2,last_type):
  self.varname=varname
  self.lifetime_number=lifetime_number
  self.lifetime_number2=lifetime_number2
  self.last_type=last_type
class O:
 def N(self,code):
  self.code=code.replace(';',' ;').replace('X[E0',';')
  self.code=self.code.replace("\n","\x01\n")
  self.code=self.code.replace("\x00","")
  src=a(self.code,posix=False)
  tokens=[]
  for _word in src:
   word=_word
   newline=False
   if _word[-1]=="\x01":
    newline=True
    word="".join(list(word)[:-1])
   if len(word)==0:
    word="\x00"
   if word in("println","print"):tokens.append(["KOut",word])
   elif word=="scanln":tokens.append(["KInput",word])
   elif word=="var":tokens.append(["KVal",word])
   elif word=="return":tokens.append(["KReturn",word])
   elif word=="cast":tokens.append(["KConvert",word])
   elif word=="free":tokens.append(["KFree",word])
   elif word=="fn":tokens.append(["KFn",word])
   elif word=="len":tokens.append(["KLen",word])
   elif word=="getchar":tokens.append(["KGetChar",word])
   elif word=="__pyexec":tokens.append(["KPydef",word])
   elif word=="__deny_pyexec":tokens.append(["KPydefDeny",word])
   elif word=="__allow_pyexec":tokens.append(["KPydefAllow",word])
   elif word=="setchar":tokens.append(["KSetChar",word])
   elif word=="nf":tokens.append(["KIndentEnd",word])
   elif word=="call":tokens.append(["KFnCall",word])
   elif word=="namespace":tokens.append(["KNamespace",word])
   elif word=="nsEnd":tokens.append(["KNamespaceEnd",word])
   elif word=="exit":tokens.append(["KExit",word])
   elif word=="loop":tokens.append(["KLoop",word])
   elif word=="break":tokens.append(["KBreak",word])
   elif word=="lend":tokens.append(["KEndLoop",word])
   elif word=="sleep":tokens.append(["KSleep",word])
   elif word=="utime":tokens.append(["KUTime",word])
   elif word=="cp":tokens.append(["KCopy",word])
   elif word=="?":tokens.append(["Comment",word])
   elif word=="-?":tokens.append(["CommentEnd",word])
   elif word=="none":tokens.append(["TNone",word])
   elif word in("true","false"):tokens.append(["TBool",word])
   elif word[0]=='"' and word[len(word)-1]=='"':tokens.append(["TStr",word[1:len(word)-1]])
   elif word=="if":tokens.append(["STif",word])
   elif word=="else":tokens.append(["STelse",word])
   elif word=="end":tokens.append(["STend",word])
   elif c("[a-z]",word)or c("[A-Z]",word):tokens.append(["Indentifier",word])
   elif word==';':tokens.append(["End",word])
   elif word in "+-=/*":tokens.append(["Op",word])
   elif word=="==":tokens.append(["Eq",word])
   elif word=="!=":tokens.append(["NEq",word])
   elif word==">":tokens.append(["More",word])
   elif word=="<":tokens.append(["Less",word])
   elif word==">=":tokens.append(["MoreEq",word])
   elif word=="<=":tokens.append(["LessEq",word])
   else:
    try:
     word = word.replace("\0", "")
     if type(eval(word))==int:tokens.append(["TInt",word])
     elif type(eval(word))==float:tokens.append(["TFloat",word])
     passed=True
    except SyntaxError:
     tokens.append(["Indentifier",word])
   if tokens[-1][1]=="\x00":
    tokens.pop()
   if newline:
    tokens.append(["NEWLINE","\x01"])
  tokens.append(["FLEnd",None])
  i=0
  while i<len(tokens):
   if tokens[i][0]=="TStr":
    tokens[i][1]=tokens[i][1].replace("\x01","")
   i+=1
  if verbose==True:
   print("Execution")
   print("Tokens:")
   print(tokens)
   print("-------\n\n")
  return tokens
class b:
 def g(self,tokens):
  global toexit,lxr,prs,variables,functions,current_scope,pyexec_allowed
  self.tokens=tokens
  c=0
  end=False
  iscomment=False
  function_definition=False
  skip_until_loop_end=False
  while c<len(tokens):
   for i in range(1,10+1):
    if scopes["essential"].scope.get(f"arg{i}")==None:scopes["essential"].scope[f"arg{i}"]=0
   if scopes["essential"].scope.get("ret")==None:scopes["essential"].scope["ret"]=0
   variables=scopes[current_scope].scope.copy()
   if current_scope!="global":
    for variable in scopes["global"].scope:
     variables[variable]=scopes["global"].scope[variable]
   for variable in scopes["essential"].scope:
    variables[variable]=scopes["essential"].scope[variable]
   prev_scope=current_scope
   if self.tokens[c][0]=="CommentEnd":iscomment=False
   if iscomment==True:
    c+=1
    continue
    pass
   if tokens[c][0]!="KEndLoop":
    if skip_until_loop_end==True:
     c+=1
     continue
     pass
   else:
    if skip_until_loop_end==True:
     skip_until_loop_end=False
   if tokens[c][0]!="End":
    if verbose:
     print(self.tokens[c][0],self.tokens[c][1])
   if toexit==1:break
   if self.tokens[c][0]=="End":end=False
   elif self.tokens[c][0]=="STend":
    if len(ifst)>0:
     ifst.pop(-1)
   elif self.tokens[c][0]=="STelse":
    if len(ifst)>0:
     ifst[-1]["elsecon"]=True
   if self.tokens[c][0]=="KIndentEnd":function_definition=False
   if end==True:
    c+=1
    continue
   if function_definition==True:
    c+=1
    continue
   if len(ifst)>0:
    if ifst[-1]["active"]==True:
     if ifst[-1]["elsecon"]==True:
      if False:
       if ifst[-1]["condition"]=="Eq":
        if variables[ifst[-1]["var"]]==variables[ifst[-1]["equal"]]:
         c+=1;continue
       elif ifst[-1]["condition"]=="NEq":
        if variables[ifst[-1]["var"]]!=variables[ifst[-1]["equal"]]:
         c+=1;continue
       elif ifst[-1]["condition"]=="More":
        if variables[ifst[-1]["var"]]>variables[ifst[-1]["equal"]]:
         c+=1;continue
       elif ifst[-1]["condition"]=="Less":
        if variables[ifst[-1]["var"]]<variables[ifst[-1]["equal"]]:
         c+=1;continue
       elif ifst[-1]["condition"]=="MoreEq":
        if variables[ifst[-1]["var"]]>=variables[ifst[-1]["equal"]]:
         c+=1;continue
       elif ifst[-1]["condition"]=="LessEq":
        if variables[ifst[-1]["var"]]<=variables[ifst[-1]["equal"]]:
         c+=1;continue
      else:
       if ifst[-1]["condition"]=="Eq":
        if ifst[-1]["var"]==ifst[-1]["equal"]:
         c+=1;continue
       elif ifst[-1]["condition"]=="NEq":
        if ifst[-1]["var"]!=ifst[-1]["equal"]:
         c+=1;continue
       elif ifst[-1]["condition"]=="More":
        if ifst[-1]["var"]<ifst[-1]["equal"]:
         pass
        else:c+=1;continue
       elif ifst[-1]["condition"]=="Less":
        if ifst[-1]["var"]>ifst[-1]["equal"]:
         pass
        else:c+=1;continue
       elif ifst[-1]["condition"]=="MoreEq":
        if ifst[-1]["var"]>=ifst[-1]["equal"]:
         pass
        else:c+=1;continue
       elif ifst[-1]["condition"]=="LessEq":
        if ifst[-1]["var"]<=ifst[-1]["equal"]:
         pass
        else:c+=1;continue
       '''
                            if ifst[-1]["condition"] == "Eq":
                                if variables[ifst[-1]["var"]] == ifst[-1]["equal"]:
                                    c += 1; continue
                            elif ifst[-1]["condition"] == "NEq":
                                if variables[ifst[-1]["var"]] != ifst[-1]["equal"]:
                                    c += 1; continue
                            elif ifst[-1]["condition"] == "More":
                                if variables[ifst[-1]["var"]] > ifst[-1]["equal"]:
                                    c += 1; continue
                            elif ifst[-1]["condition"] == "Less":
                                if variables[ifst[-1]["var"]] < ifst[-1]["equal"]:
                                    c += 1; continue
                            elif ifst[-1]["condition"] == "MoreEq":
                                if variables[ifst[-1]["var"]] >= ifst[-1]["equal"]:
                                    c += 1; continue
                            elif ifst[-1]["condition"] == "LessEq":
                                if variables[ifst[-1]["var"]] <= ifst[-1]["equal"]:
                                    c += 1; continue'''
     else:
      if False:
       if ifst[-1]["condition"]=="Eq":
        if variables[ifst[-1]["var"]]!=variables[ifst[-1]["equal"]]:
         c+=1;continue
       elif ifst[-1]["condition"]=="NEq":
        if variables[ifst[-1]["var"]]==variables[ifst[-1]["equal"]]:
         c+=1;continue
       elif ifst[-1]["condition"]=="More":
        if variables[ifst[-1]["var"]]<variables[ifst[-1]["equal"]]:
         c+=1;continue
       elif ifst[-1]["condition"]=="Less":
        if variables[ifst[-1]["var"]]>variables[ifst[-1]["equal"]]:
         c+=1;continue
       elif ifst[-1]["condition"]=="MoreEq":
        if variables[ifst[-1]["var"]]<=variables[ifst[-1]["equal"]]:
         c+=1;continue
       elif ifst[-1]["condition"]=="LessEq":
        if variables[ifst[-1]["var"]]>=variables[ifst[-1]["equal"]]:
         c+=1;continue
      else:
       if ifst[-1]["condition"]=="Eq":
        if ifst[-1]["var"]!=ifst[-1]["equal"]:
         c+=1;continue
       elif ifst[-1]["condition"]=="NEq":
        if ifst[-1]["var"]==ifst[-1]["equal"]:
         c+=1;continue
       elif ifst[-1]["condition"]=="More":
        if ifst[-1]["var"]<ifst[-1]["equal"]:
         c+=1;continue
       elif ifst[-1]["condition"]=="Less":
        if ifst[-1]["var"]>ifst[-1]["equal"]:
         c+=1;continue
       elif ifst[-1]["condition"]=="MoreEq":
        if ifst[-1]["var"]<=ifst[-1]["equal"]:
         c+=1;continue
       elif ifst[-1]["condition"]=="LessEq":
        if ifst[-1]["var"]>=ifst[-1]["equal"]:
         c+=1;continue
       '''
                            if ifst[-1]["condition"] == "Eq":
                                if variables[ifst[-1]["var"]] != ifst[-1]["equal"]:
                                    c += 1; continue
                            elif ifst[-1]["condition"] == "NEq":
                                if variables[ifst[-1]["var"]] == ifst[-1]["equal"]:
                                    c += 1; continue
                            elif ifst[-1]["condition"] == "More":
                                if variables[ifst[-1]["var"]] < ifst[-1]["equal"]:
                                    c += 1; continue
                            elif ifst[-1]["condition"] == "Less":
                                if variables[ifst[-1]["var"]] > ifst[-1]["equal"]:
                                    c += 1; continue
                            elif ifst[-1]["condition"] == "MoreEq":
                                if variables[ifst[-1]["var"]] <= ifst[-1]["equal"]:
                                    c += 1; continue
                            elif ifst[-1]["condition"] == "LessEq":
                                if variables[ifst[-1]["var"]] >= ifst[-1]["equal"]:
                                    c += 1; continue'''
   if self.tokens[c][0]=="KOut":
    if self.tokens[c+1][0]not in("TStr","Indentifier"):
     v.o("Out.TypeError","Only strings accepted");continue
    s=str(self.tokens[c+1][1])
    if self.tokens[c+1][0]=="Indentifier":
     s=str(variables[self.tokens[c+1][1]])
    if self.tokens[c][1]=="println":
     s+="\n"
    cvars=""
    cs=""
    cvar=False
    ent=False
    for char in s:
     if char=='^':
      cvar=False
      ent=True
     if cvar==True:
      cvars+=char
     else:
      if cvars:
       for var in variables:
        if str(var)==cvars:
         cs+=str(variables[str(var)])
       cvars=""
     if char=='$':cvar=True
     else:
      if cvar==False and ent==False:cs+=char
     ent=False
    cs=cs.replace('\\n','\n')
    print(cs)
    end=True
   elif self.tokens[c][0]=="KPydef":
    if pyexec_allowed:
     if self.tokens[c+1][0]!="TStr":
      v.o("KPydef.TypeError","");continue
     if "import inspect" in self.tokens[c+1][1]or("inspect.getsource" in self.tokens[c+1][1]or("from inspect" in self.tokens[c+1][1])):
      exit(69)
     try:
      exec(self.tokens[c+1][1],globals(),globals())
     except BaseException as e:
      print(e)
      print(self.tokens[c+1][1])
   elif self.tokens[c][0]=="KPydefDeny":
    pyexec_allowed=False
   elif self.tokens[c][0]=="KPydefAllow":
    pyexec_allowed=True
   elif self.tokens[c][0]=="KConvert":
    vartype=str(type(self.tokens[c+1][0])).replace('<class ','').replace(">",'').replace("'",'')
    if self.tokens[c+1][0]!="Indentifier":
     if len(self.tokens[c+1][1])>=1:
      if self.tokens[c+1][1][0]!="@":
       v.o("Convert.ExceptionError","Excepted variable name as indendifier");continue
    elif self.tokens[c+2][1]not in "intfloatstrnonebool":
     v.o("Convert.TypeError","Unknown type to convert");continue
    try:
     if self.tokens[c+2][1]=="none":variables[self.tokens[c+1][1]]=None
     else:
      if self.tokens[c+2][1]=="int":
       variables[self.tokens[c+1][1]]=int(variables[self.tokens[c+1][1]])
      if self.tokens[c+2][1]=="float":
       variables[self.tokens[c+1][1]]=float(variables[self.tokens[c+1][1]])
      if self.tokens[c+2][1]=="str":
       variables[self.tokens[c+1][1]]=str(variables[self.tokens[c+1][1]])
      if self.tokens[c+2][1]=="bool":
       variables[self.tokens[c+1][1]]=bool(variables[self.tokens[c+1][1]])
    except EOFError:v.o("ConvertationError",f"Cannot convert {vartype} -> {self.tokens[c+2][1]}")
    end=True
   elif self.tokens[c][0]=="KFn":
    if self.tokens[c+1][0]!="Indentifier":
     v.o("BlockDefinition.NamingError","Excepted function name as indendifier");continue
    if verbose:print(self.tokens[c+3][1])
    fn_name=self.tokens[c+1][1]
    if namespace_info["active"]==True:
     fn_name=namespace_info["name"]+"::"+self.tokens[c+1][1]
    if self.tokens[c+1][1].count(':')>0:
     v.o("BlockDefinition.NamingError","Invalid name");continue
    functions[fn_name]=c+2
    function_definition=True
    c+=1;continue
   elif self.tokens[c][0]=="KLoop":
    loopst.append({"index":c+1})
    c+=1;continue
   elif self.tokens[c][0]=="KEndLoop":
    if len(loopst)>0:
     c=loopst[-1]["index"]
     continue
   elif self.tokens[c][0]=="KBreak":
    if len(loopst)>0:
     loopst.pop()
     skip_until_loop_end=True
   elif self.tokens[c][0]=="KGoto1":
    if self.tokens[c+1][0]=="TInt":
     v.o("Goto.TypeError","Excepted line as int")
    nlines=[]
    for ctkn in self.tokens:
     pass
    c=int(self.tokens[c+1][1])
   elif self.tokens[c][0]=="KSleep":
    if self.tokens[c+1][0]not in("TInt","TFloat"):
     v.o("KSleep.TimeError","Excepted time as int or float")
    I(float(self.tokens[c+1][1]))
   elif self.tokens[c][0]=="KUTime":
    if self.tokens[c+1][0]!="Indentifier":
     v.o("KUTime.TimeError","Excepted var name as identifier")
    variables[self.tokens[c+1][1]]=d()
   elif self.tokens[c][0]=="KIndentEnd":
    if len(line_stamps)>0:
     c=line_stamps[-1]
     line_stamps.pop(-1)
     continue
   elif self.tokens[c][0]=="KFnCall":
    if self.tokens[c+1][0]!="Indentifier":
     v.o("FunctionCall.NamingError","Excepted function name as indendifier");continue
    if verbose:
     print(functions)
     print(self.tokens[c+1][1])
    if self.tokens[c+1][1]in list(functions):
     argc=1
     while self.tokens[c+1+argc][0]!="End":
      var=self.tokens[c+1+argc][1]
      if self.tokens[c+1+argc][0]=="Indentifier":
       var=variables[self.tokens[c+1+argc][1]]
      if self.tokens[c+1+argc][0]=="TInt":var=int(var)
      elif self.tokens[c+1+argc][0]=="TFloat":var=float(var)
      if argc<=10:
       variables[f"arg{argc}"]=var
      argc+=1
     line_stamps.append(c+3)
     c=functions[self.tokens[c+1][1]]
     if verbose:print(line_stamps)
    else:
     v.o("FunctionCall.NoFunctionError",f"No such function: {self.tokens[c+1][1]}");continue
   elif self.tokens[c][0]=="KVal":
    if self.tokens[c+1][0]!="Indentifier":
     if verbose:
      print(self.tokens[c+1][1])
     if len(self.tokens[c+1][1])>=1:
      if self.tokens[c+1][1][0]not in("@"):
       v.o("Val.ExceptionError","Excepted variable name as indendifier");continue
     else:
      v.o("Val.ExceptionError","Excepted variable name as indendifier");continue
    elif self.tokens[c+2][0]!="Op":
     v.o("Val.ExceptionError","Excepted equal sign to define variable");continue
    if self.tokens[c+1][1][0]=='!':
     v.o("Val.ReservedError","Cannot manage with language-reserved variables");continue
    if namespace_info['active']==True:
     if self.tokens[c+2][1]=='=':
      if self.tokens[c+1][1]not in list(variables):
       if self.tokens[c+1][1][0]!='@':
        self.tokens[c+1][1]=namespace_info['name']+'::'+self.tokens[c+1][1]
       else:
        self.tokens[c+1][1]='@'+namespace_info['name']+'::'+self.tokens[c+1][1][1:]
    else:
     if self.tokens[c+1][1].count(":")>0:
      if self.tokens[c+1][1]not in list(variables):
       v.o("Val.NamingError","Invaild name");continue
    if self.tokens[c+2][1]=='=':
     if self.tokens[c+1][1]in list(variables):
      if self.tokens[c+1][1][0]=="@":
       v.o("Val.ExceptionError","Cannot assign to constant variable");continue
     if self.tokens[c+3][0]=="TStr":
      variables[self.tokens[c+1][1]]=str(self.tokens[c+3][1])
     elif self.tokens[c+3][0]=="TInt":
      variables[self.tokens[c+1][1]]=int(self.tokens[c+3][1])
     elif self.tokens[c+3][0]=="TFloat":
      variables[self.tokens[c+1][1]]=float(self.tokens[c+3][1])
     elif self.tokens[c+3][0]=="Indentifier":
      variables[self.tokens[c+1][1]]=variables[self.tokens[c+3][1]]
     elif self.tokens[c+3][0]=="TNone":
      variables[self.tokens[c+1][1]]=None
     elif self.tokens[c+3][0]=="TBool":
      if self.tokens[c+3][1]=="true":variables[self.tokens[c+1][1]]=True
      if self.tokens[c+3][1]=="false":variables[self.tokens[c+1][1]]=False
     else:
      v.o("Val.TypeError",f"Unsupported type for variable ({self.tokens[c+3][0]})");continue
    elif self.tokens[c+2][1]=='+':
     if self.tokens[c+1][1]in list(variables):
      if self.tokens[c+1][1][0]=="@":
       v.o("Val.ExceptionError","Cannot assign to constant variable");continue
     if self.tokens[c+3][0]=="TInt":
      variables[self.tokens[c+1][1]]+=int(self.tokens[c+3][1])
     elif self.tokens[c+3][0]=="TFloat":
      variables[self.tokens[c+1][1]]+=float(self.tokens[c+3][1])
     elif self.tokens[c+3][0]=="Indentifier":
      variables[self.tokens[c+1][1]]+=variables[self.tokens[c+3][1]]
    elif self.tokens[c+2][1]=='-':
     if self.tokens[c+1][1]in list(variables):
      if self.tokens[c+1][1][0]=="@":
       v.o("Val.ExceptionError","Cannot assign to constant variable");continue
     if self.tokens[c+3][0]=="TInt":
      variables[self.tokens[c+1][1]]-=int(self.tokens[c+3][1])
     elif self.tokens[c+3][0]=="TFloat":
      variables[self.tokens[c+1][1]]-=float(self.tokens[c+3][1])
     elif self.tokens[c+3][0]=="Indentifier":
      variables[self.tokens[c+1][1]]-=variables[self.tokens[c+3][1]]
     else:
      variables[self.tokens[c+1][1]]-=self.tokens[c+3][1]
    elif self.tokens[c+2][1]=='/':
     if self.tokens[c+1][1]in list(variables):
      if self.tokens[c+1][1][0]=="@":
       v.o("Val.ExceptionError","Cannot assign to constant variable");continue
     if self.tokens[c+3][0]=="TInt":
      variables[self.tokens[c+1][1]]=variables[self.tokens[c+1][1]]//int(self.tokens[c+3][1])
     elif self.tokens[c+3][0]=="TFloat":
      variables[self.tokens[c+1][1]]=variables[self.tokens[c+1][1]]/float(self.tokens[c+3][1])
     elif self.tokens[c+3][0]=="Indentifier":
      variables[self.tokens[c+1][1]]=variables[self.tokens[c+1][1]]/variables[self.tokens[c+3][1]]
     else:
      variables[self.tokens[c+1][1]]=variables[self.tokens[c+1][1]]/self.tokens[c+3][1]
    elif self.tokens[c+2][1]=='*':
     if self.tokens[c+1][1]in list(variables):
      if self.tokens[c+1][1][0]=="@":
       v.o("Val.ExceptionError","Cannot assign to constant variable");continue
     if self.tokens[c+3][0]=="TInt":
      variables[self.tokens[c+1][1]]*=int(self.tokens[c+3][1])
     elif self.tokens[c+3][0]=="TFloat":
      variables[self.tokens[c+1][1]]*=float(self.tokens[c+3][1])
     elif self.tokens[c+3][0]=="Indentifier":
      variables[self.tokens[c+1][1]]*=variables[self.tokens[c+3][1]]
     else:
      variables[self.tokens[c+1][1]]*=self.tokens[c+3][1]
    else:
     v.o("Val.OpError",f"Unsupported operator: {self.tokens[c+2][1]}");continue
     end=True
   elif self.tokens[c][0]=="STif":
    if self.tokens[c+1][0]!="Indentifier":
     v.o("Statement.If","Not a variable");continue
    elif self.tokens[c+2][0]not in("Eq","NEq","More","Less","MoreEq","LessEq"):
     v.o("Statement.If","Condition not found");continue
    ifst.append({})
    ifst[-1]["active"]=True
    ifst[-1]["elsecon"]=False
    ifst[-1]["var"]=self.tokens[c+1][1]
    ifst[-1]["condition"]=self.tokens[c+2][0]
    ifst[-1]["equal"]=self.tokens[c+3][1]
    if self.tokens[c+3][0]=="TInt":
     ifst[-1]["equal"]=int(self.tokens[c+3][1])
    if self.tokens[c+3][0]=="TFloat":
     ifst[-1]["equal"]=float(self.tokens[c+3][1])
    if ifst[-1]["var"]in variables:
     ifst[-1]["var"]=variables[ifst[-1]["var"]]
    if ifst[-1]["equal"]in variables:
     ifst[-1]["equal"]=variables[ifst[-1]["equal"]]
    if ifst[-1]["var"]==ifst[-1]["equal"]and(ifst[-1]["condition"]in("MoreEq","LessEq")):
     ifst[-1]["condition"]="Eq"
    if ifst[-1]["var"]==ifst[-1]["equal"]and(ifst[-1]["condition"]in("More","Less")):
     ifst[-1]["condition"]="NEq"
   elif self.tokens[c][0]=="KInput":
    if self.tokens[c+1][0]!="Indentifier":
     v.o("in.TypeError","Cannot write to non-variable identifier");continue
    while True:
     kinput=input_stream[0]
     input_stream.pop(0)
     print(kinput)
     break
    variables[self.tokens[c+1][1]]=str(kinput)
    end=True
   elif self.tokens[c][0]=='Comment':
    iscomment=True
   elif self.tokens[c][0]=="STelse":
    if len(ifst)>0:ifst[-1]["elsecon"]=True
   elif self.tokens[c][0]=="KInclude":
    print("In-File Including not supported")
    exit(1)
    if self.tokens[c+1][0]!="TStr":
     v.o("Include.TypeError","Excepted file name as string");continue
    include_file=self.tokens[c+1][1]+'.wpp'
    Y("wpp "+include_file)
    end=True
   elif self.tokens[c][0]=="KExit":
    if self.tokens[c+1][0]not in["TInt","Indentifier"]:
     v.o("Exit.TypeError","Excepted integer or variable");continue
    if self.tokens[c+1][0]=="TInt":
     print("[Program exited with code "+str(variables[str(self.tokens[c+1][1])])+"]")
    elif self.tokens[c+1][0]=="Indentifier":
     try:
      print("[Program exited with code "+str(variables[str(self.tokens[c+1][1])])+"]")
     except ValueError:
      v.o("Exit.TypeError","Excepted integer or variable");continue
   elif self.tokens[c][0]=="KReturn":
    if self.tokens[c+1][0]not in["TInt","Indentifier"]:
     v.o("Return.TypeError","Excepted integer or variable");continue
    if self.tokens[c+1][0]=="TInt":
     variables["ret"]=int(self.tokens[c+1][1])
    elif self.tokens[c+1][0]=="Indentifier":
     try:
      variables["ret"]=int(variables[str(self.tokens[c+1][1])])
     except ValueError:
      v.o("Return.TypeError","Excepted integer or variable");continue
   elif self.tokens[c][0]=="KFree":
    if self.tokens[c+1][0]!="Indentifier":
     if self.tokens[c+1][0]!="TStr":
      v.o("Free.TypeError","Excepted variable");continue
    if self.tokens[c+1][1][0]=='!':
     v.o("Free.ReservedError","Cannot manage with language-reserved variables");continue
    if self.tokens[c+1][1]=="*":
     nvariables={}
     for variable in variables:
      if str(variable)[0]=='!':
       nvariables[str(variable)]=variables[str(variable)]
     variables=nvariables
     S.o("Free.WFreeAll","Freeing all variables is not secure")
    else:
     try:
      del variables[self.tokens[c+1][1]]
     except KeyError:
      v.o("Free.KeyError","Cannot find variable");continue
    end=True
   elif self.tokens[c][0]=="KLen":
    if self.tokens[c+1][0]!="Indentifier":
     v.o("Len.TypeError","Excepted identifier as variable name")
    if self.tokens[c+2][0]!="Indentifier":
     v.o("Len.TypeError","Excepted identifier as variable name")
    variables[self.tokens[c+2][1]]=len(str(variables[self.tokens[c+1][1]]))
   elif self.tokens[c][0]=="KNamespace":
    if self.tokens[c+1][0]!="Indentifier":
     v.o("KNamespace.TypeError","Excepted identifier as namespace name")
    namespace_info['active']=True
    namespace_info['name']=self.tokens[c+1][1]
   elif self.tokens[c][0]=="KNamespaceEnd":
    namespace_info['active']=False
    namespace_info['name']=""
   elif self.tokens[c][0]=="KSetChar":
    if self.tokens[c+1][0]!="Indentifier":
     v.o("SetChar.TypeError",f"Excepted identifier as variable name")
    if self.tokens[c+2][0]!="TStr":
     v.o("SetChar.TypeError",f"Excepted character as string, not {self.tokens[c+2][0]}")
    if self.tokens[c+3][0]!="TInt":
     v.o("SetChar.TypeError",f"Excepted element pos as integer")
    var_as_list=list(str(variables[self.tokens[c+1][1]]))
    var_as_list[int(self.tokens[c+3][1])]=self.tokens[c+2][1][0]
    variables[self.tokens[c+1][1]]=''.join(var_as_list)
   elif self.tokens[c][0]=="KGetChar":
    if self.tokens[c+1][0]!="Indentifier":
     v.o("SetChar.TypeError",f"Excepted identifier as variable name")
    if self.tokens[c+2][0]!="TInt":
     v.o("SetChar.TypeError",f"Excepted character as integer, not {self.tokens[c+2][0]}")
    if self.tokens[c+3][0]!="Indentifier":
     v.o("SetChar.TypeError",f"Excepted output variable as identifier, not {self.tokens[c+3][0]}")
    variables[self.tokens[c+3][1]]=variables[self.tokens[c+1][1]][int(self.tokens[c+2][1])]
   elif self.tokens[c][0]=="KCopy":
    if self.tokens[c+1][0]!="Indentifier":
     v.o("SetChar.TypeError",f"Excepted identifier as variable name")
    if self.tokens[c+2][0]!="Indentifier":
     v.o("SetChar.TypeError",f"Excepted identifier as variable name")
    variables[self.tokens[c+1][1]]=variables[self.tokens[c+2][1]]
   for i in range(1,10+1):
    scopes["essential"].scope[f"arg{i}"]=variables[f"arg{i}"]
   scopes["essential"].scope["ret"]=variables["ret"]
   if prev_scope==current_scope:
    scopes[current_scope].scope=variables
   else:
    if prev_scope in scopes:
     scopes[prev_scope].scope=variables
   c+=1
def k(*exc_info):
 lifecycle_running=False
 tc="".join(F(*exc_info))
 print(f'''
WPP: Unexcepted error
------------------------
 {tc}''')
lifecycle_running=False
def B():
 global variables
 '''
    for var, val in variables.items():
        if var[0] == "&":
            pointers[var] = val
    for ptr, valptr in pointers.items():
        if ptr not in variables:
            del variables[ptr]'''
 while lifecycle_running:
  if len(scopes[current_scope].timed_vars)>0:
   i=0
   while i<len(scopes[current_scope].timed_vars):
    timedvar=scopes[current_scope].timed_vars[i]
    if int(C())>=timedvar.lifetime_number2+timedvar.lifetime_number:
     scopes[current_scope].timed_vars.remove(timedvar)
     scopes[current_scope].scope.pop(timedvar.varname)
     variables.pop(timedvar.varname)
   i+=1
is_imgui_closed=False
inter=0
verbose=False
def i(code:str):
 global variables,functions,ifst,namespace_info,loopst,line_stamps
 variables={"!hello":"Hello, world!","WPPinput_nonblocking":0}
 functions={}
 ifst=[{"var":None,"equal":None,"active":False,"elsecon":False}]
 namespace_info={"active":False,"name":""}
 ifst=[]
 loopst=[]
 line_stamps=[]
 V=k
 lxr=O()
 prs=b()
 additional_code=""
 additional_code+=f"{code}\n"
 additional_code+="\n\n"
 default_lib='''
# Watermelon++ default lib
namespace std;
fn stradd;
__pyexec "variables[\'arg1\'] += str(variables[\'arg2\'])";
nf;
fn strsplit;
__pyexec "variables[\'ret\'] = variables[\'arg1\'].split(variables[\'arg2\'])";
nf;
nsEnd;
namespace timedvar;
fn seconds;
__pyexec "scopes[current_scope].timed_vars.append( U(variables[\'arg1\'], int(variables[\'arg2\']), int(time.time()), \'seconds\') )";
nf;
nsEnd;
namespace scope;
fn change_scope;
__pyexec "current_scope = variables[\'arg1\']";
nf;
fn new_scope;
__pyexec "scopes[variables[\'arg1\']] = h()"
nf;
fn delete_scope;
__pyexec "if variables[\'arg1\'] != \'global\': del scopes[variables[\'arg1\']]\nif current_scope == variables[\'arg1\']: current_scope = \'global\'";
nf;
nsEnd;
namespace array;
fn new;
__pyexec "variables[variables[\'arg1\']] = []";
nf;
fn get;
__pyexec "variables[\'ret\'] = variables[variables[\'arg1\']][variables[\'arg2\']]";
nf;
fn append;
__pyexec "variables[variables[\'arg1\']].append(variables[\'arg2\'])";
nf;
fn pop;
__pyexec "variables[\'ret\'] = variables[variables[\'arg1\']].pop()";
nf;
fn delete;
__pyexec "del variables[variables[\'arg1\']][variables[\'arg2\']]";
nf;
fn set;
__pyexec "variables[variables[\'arg1\']][variables[\'arg2\']] = variables[\'arg3\']";
nf;
fn size;
__pyexec "variables[\'ret\'] = len(variables[variables[\'arg1\']])";
nf;
nsEnd;
namespace RegEx;
fn BoolMatch;
__pyexec "variables[\'ret\'] = int(bool(re.search(variables[\'arg1\'], variables[\'arg2\'])))";
nf;
nsEnd;
namespace hashmap;
fn new;
__pyexec "variables[variables[\'arg1\']] = {}";
nf;
fn get;
__pyexec "variables[\'ret\'] = variables[variables[\'arg1\']].get(variables[\'arg2\'])";
nf;
fn set;
__pyexec "variables[variables[\'arg1\']][variables[\'arg2\']] = variables[\'arg3\']";
nf;
fn delete;
__pyexec "del variables[variables[\'arg1\']][variables[\'arg2\']]";
nf;
nsEnd;
'''
 additional_code+="\n\n"+default_lib
 mod_code=additional_code+code+"\n\n\ncall main; exit ret;"
 tkns=lxr.N(mod_code)
 lifecycle_running=True
 prs.g(tkns)
 lifecycle_running=False

input_stream = []
def runCode(*args):
 global input_stream
 print("[-=wpp=-] Running")
 input_stream = document.getElementById("input_stream").value.split("\n")
 i(document.getElementById("code").value)

from pyodide.ffi import create_proxy
from js import document
runCode_js = create_proxy(runCode)
run_button = document.getElementById("run_button")
run_button.addEventListener("click", runCode_js)

print("[wppinit] Watermelon++ loaded")
print("[wppinit] You can work now!")

            </script>

            <script type="py">

            </script>
        </section>
    </body>
</html>
